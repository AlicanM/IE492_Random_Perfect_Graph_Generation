\section{Conclusions and Discussion}

In this project, C++ is used to implement and test the algorithms which try to generate perfect graphs as random as possible. This requires the application of fundamental concepts from industrial engineering at the undergraduate level, including graph theory and the algorithm design. 

Graph Theory is a mathematical field focusing on the mathematical structures, namely graphs which have many real-life applications. Furthermore, perfect graph class is a special structured graph class, where the perfect class and its sub-classes are well-studied. There are different algorithms developed for such graph classes, which might be in polynomial time, approximation or heuristic algorithms. It is necessary to have a list of random graphs to test and evaluate the performance of these algorithms. Therefore, it is convenient to generate random perfect graphs in different size and density. For our study, we implemented two different algorithms. Firstly, we proposed a combinatorial algorithm using a open-source pool source of perfect graphs and known perfectness-preserving operations. Then, we proposed a heuristic repair algorithm having either a random graph, or a $C_{5}$-free graph as starting graph and making some edge modifications (repair) to finally result in a perfect graph. At the end, we made comparisons between the algorithms. 

Finally, we concluded that we can generate as many perfect graphs as possible in different size and density by using the combinatorial algorithm since this approach is fast. However, the drawback of this method is that this method is limited by a number operations and cannot generate every perfect graph with positive probability. On the other hand, our heuristic repair approach is better since we can generate perfect graphs with positive probability; however, this method takes long hours of computation. This result comes from the perfectness check used in many iterations. In this project, we faced the trade-off between the randomness and the time complexity for different methods. Also, in our experimentation sessions, there is an experimental limit for generated graphs in terms of density and size. We could not generate any perfect graph in some specific size and density for the heuristic method in reasonable time.

As a future work, we propose some improvements for the heuristic repair algorithm. The algorithm is needed to be tested with the clean odd cycle-free graphs as starting graphs. Also, the combinatorial algorithm can be improved by adding new possible operations such as amalgam~\cite{burlet}, 2-amalgam~\cite{cornuejols} or 2-join, double star cut-set or skew partition~\cite{trotignon} in addition to the ones defined in this study. These operations are more complex, but it gives an opportunity to generate more diverse graphs. 